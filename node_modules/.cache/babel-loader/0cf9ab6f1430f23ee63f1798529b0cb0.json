{"ast":null,"code":"var _jsxFileName = \"/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js\";\nimport React, { useEffect, useState, useRef } from 'react';\nimport getTrendingTerms from '../../services/getTrendingTermsServices';\nimport Category from '../Category';\n\nfunction TrendingSearches() {\n  const [trends, setTrends] = useState([]);\n  useEffect(function () {\n    getTrendingTerms().then(setTrends);\n  }, []);\n  return /*#__PURE__*/React.createElement(Category, {\n    name: \"Tendencias\",\n    options: trends,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 12\n    }\n  });\n}\n\nexport default function LazyTrending() {\n  const [show, setShow] = useState(false);\n  const elementRef = useRef();\n  useEffect(function () {\n    // Funcion a ejecutar cuando haya cambios en la interseccion\n    const onChange = (entries, observer) => {\n      //Recuperamos el elemento\n      const el = entries[0]; // si el elemento es intersectado\n\n      if (el.isIntersecting) {\n        setShow(true);\n        observer.disconnect();\n      }\n    }; // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n\n\n    const observer = new IntersectionObserver(onChange, {\n      rootMargin: '100px'\n    }); //empezamos a observar\n    // para acceder al valor de la referencia se ocupa .current\n\n    observer.observe(elementRef.current); // recibe el elemento a observar\n\n    return () => observer.disconnect();\n  });\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: elementRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 12\n    }\n  }, show ? /*#__PURE__*/React.createElement(TrendingSearches, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 17\n    }\n  }) : null);\n}","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js"],"names":["React","useEffect","useState","useRef","getTrendingTerms","Category","TrendingSearches","trends","setTrends","then","LazyTrending","show","setShow","elementRef","onChange","entries","observer","el","isIntersecting","disconnect","IntersectionObserver","rootMargin","observe","current"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,QAAmD,OAAnD;AACA,OAAOC,gBAAP,MAA6B,yCAA7B;AACA,OAAOC,QAAP,MAAqB,aAArB;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,EAAD,CAApC;AAIAD,EAAAA,SAAS,CAAC,YAAW;AAEjBG,IAAAA,gBAAgB,GAAGK,IAAnB,CAAwBD,SAAxB;AACH,GAHQ,EAGN,EAHM,CAAT;AAKA,sBAAO,oBAAC,QAAD;AAAU,IAAA,IAAI,EAAE,YAAhB;AAA6B,IAAA,OAAO,EAAID,MAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAP;AACH;;AAED,eAAe,SAASG,YAAT,GAAuB;AAClC,QAAM,CAACC,IAAD,EAAMC,OAAN,IAAiBV,QAAQ,CAAC,KAAD,CAA/B;AACA,QAAMW,UAAU,GAAGV,MAAM,EAAzB;AACAF,EAAAA,SAAS,CAAC,YAAU;AAChB;AACA,UAAMa,QAAQ,GAAG,CAACC,OAAD,EAAUC,QAAV,KAAsB;AACnC;AACA,YAAMC,EAAE,GAAGF,OAAO,CAAC,CAAD,CAAlB,CAFmC,CAGnC;;AACA,UAAIE,EAAE,CAACC,cAAP,EAAsB;AAClBN,QAAAA,OAAO,CAAC,IAAD,CAAP;AACAI,QAAAA,QAAQ,CAACG,UAAT;AACH;AACJ,KARD,CAFgB,CAYhB;;;AACA,UAAMH,QAAQ,GAAG,IAAII,oBAAJ,CAAyBN,QAAzB,EAAmC;AAChDO,MAAAA,UAAU,EAAC;AADqC,KAAnC,CAAjB,CAbgB,CAiBhB;AACA;;AACAL,IAAAA,QAAQ,CAACM,OAAT,CAAiBT,UAAU,CAACU,OAA5B,EAnBgB,CAmBqB;;AAErC,WAAO,MAAMP,QAAQ,CAACG,UAAT,EAAb;AACH,GAtBQ,CAAT;AAwBA,sBAAO;AAAK,IAAA,GAAG,EAAIN,UAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAEFF,IAAI,gBAAG,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAH,GAA0B,IAF5B,CAAP;AAIH","sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\nimport getTrendingTerms from '../../services/getTrendingTermsServices'\nimport Category from '../Category'\n\nfunction TrendingSearches (){\n    const [trends, setTrends] = useState([])\n    \n\n\n    useEffect(function() {\n\n        getTrendingTerms().then(setTrends)\n    }, [])\n    \n    return <Category name= 'Tendencias' options = {trends}/>\n}\n\nexport default function LazyTrending(){\n    const [show,setShow] = useState(false)\n    const elementRef = useRef()\n    useEffect(function(){\n        // Funcion a ejecutar cuando haya cambios en la interseccion\n        const onChange = (entries, observer) =>{\n            //Recuperamos el elemento\n            const el = entries[0]\n            // si el elemento es intersectado\n            if (el.isIntersecting){\n                setShow(true)\n                observer.disconnect()\n            }\n        }\n\n        // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n        const observer = new IntersectionObserver(onChange, {\n            rootMargin:'100px'\n        })\n\n        //empezamos a observar\n        // para acceder al valor de la referencia se ocupa .current\n        observer.observe(elementRef.current) // recibe el elemento a observar\n        \n        return () => observer.disconnect()\n    })\n\n    return <div ref = {elementRef}>\n        \n        {show ? <TrendingSearches /> : null}\n    </div>\n}"]},"metadata":{},"sourceType":"module"}