{"ast":null,"code":"var _jsxFileName = \"/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js\";\nimport React, { useEffect, useState, useRef } from 'react';\nimport getTrendingTerms from '../../services/getTrendingTermsServices';\nimport Category from '../Category';\n\nfunction TrendingSearches() {\n  const [trends, setTrends] = useState([]);\n  useEffect(function () {\n    getTrendingTerms().then(setTrends);\n  }, []);\n  return /*#__PURE__*/React.createElement(Category, {\n    name: \"Tendencias\",\n    options: trends,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 12\n    }\n  });\n}\n\nexport default function LazyTrending() {\n  const [show, setShow] = useState(false);\n  const elementRef = useRef();\n  useEffect(function () {\n    // Funcion a ejecutar cuando haya cambios en la interseccion\n    const onChange = entries => {\n      //Recuperamos el elemento\n      const el = entries[0];\n      console.log(el.isIntersecting); // si el elemento es intersectado\n\n      if (el.isIntersecting) {\n        setShow(true);\n      }\n    }; // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n\n\n    const observer = new IntersectionObserver(onChange, {\n      rootMargin: '100px'\n    }); //empezamos a observar\n    // para acceder al valor de la referencia se ocupa .current\n\n    observer.observe(elementRef.current); // recibe el elemento a observar\n  });\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: elementRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 12\n    }\n  }, show ? /*#__PURE__*/React.createElement(TrendingSearches, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 17\n    }\n  }) : null);\n}","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js"],"names":["React","useEffect","useState","useRef","getTrendingTerms","Category","TrendingSearches","trends","setTrends","then","LazyTrending","show","setShow","elementRef","onChange","entries","el","console","log","isIntersecting","observer","IntersectionObserver","rootMargin","observe","current"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,QAAmD,OAAnD;AACA,OAAOC,gBAAP,MAA6B,yCAA7B;AACA,OAAOC,QAAP,MAAqB,aAArB;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,EAAD,CAApC;AAIAD,EAAAA,SAAS,CAAC,YAAW;AAEjBG,IAAAA,gBAAgB,GAAGK,IAAnB,CAAwBD,SAAxB;AACH,GAHQ,EAGN,EAHM,CAAT;AAKA,sBAAO,oBAAC,QAAD;AAAU,IAAA,IAAI,EAAE,YAAhB;AAA6B,IAAA,OAAO,EAAID,MAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAP;AACH;;AAED,eAAe,SAASG,YAAT,GAAuB;AAClC,QAAM,CAACC,IAAD,EAAMC,OAAN,IAAiBV,QAAQ,CAAC,KAAD,CAA/B;AACA,QAAMW,UAAU,GAAGV,MAAM,EAAzB;AACAF,EAAAA,SAAS,CAAC,YAAU;AAChB;AACA,UAAMa,QAAQ,GAAIC,OAAD,IAAY;AACzB;AACA,YAAMC,EAAE,GAAGD,OAAO,CAAC,CAAD,CAAlB;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAYF,EAAE,CAACG,cAAf,EAHyB,CAIzB;;AACA,UAAIH,EAAE,CAACG,cAAP,EAAsB;AAClBP,QAAAA,OAAO,CAAC,IAAD,CAAP;AACH;AACJ,KARD,CAFgB,CAYhB;;;AACA,UAAMQ,QAAQ,GAAG,IAAIC,oBAAJ,CAAyBP,QAAzB,EAAmC;AAChDQ,MAAAA,UAAU,EAAC;AADqC,KAAnC,CAAjB,CAbgB,CAiBhB;AACA;;AACAF,IAAAA,QAAQ,CAACG,OAAT,CAAiBV,UAAU,CAACW,OAA5B,EAnBgB,CAmBqB;AACxC,GApBQ,CAAT;AAsBA,sBAAO;AAAK,IAAA,GAAG,EAAIX,UAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAEFF,IAAI,gBAAG,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAH,GAA0B,IAF5B,CAAP;AAIH","sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\nimport getTrendingTerms from '../../services/getTrendingTermsServices'\nimport Category from '../Category'\n\nfunction TrendingSearches (){\n    const [trends, setTrends] = useState([])\n    \n\n\n    useEffect(function() {\n\n        getTrendingTerms().then(setTrends)\n    }, [])\n    \n    return <Category name= 'Tendencias' options = {trends}/>\n}\n\nexport default function LazyTrending(){\n    const [show,setShow] = useState(false)\n    const elementRef = useRef()\n    useEffect(function(){\n        // Funcion a ejecutar cuando haya cambios en la interseccion\n        const onChange = (entries) =>{\n            //Recuperamos el elemento\n            const el = entries[0]\n            console.log(el.isIntersecting)\n            // si el elemento es intersectado\n            if (el.isIntersecting){\n                setShow(true)\n            }\n        }\n\n        // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n        const observer = new IntersectionObserver(onChange, {\n            rootMargin:'100px'\n        })\n\n        //empezamos a observar\n        // para acceder al valor de la referencia se ocupa .current\n        observer.observe(elementRef.current) // recibe el elemento a observar\n    })\n\n    return <div ref = {elementRef}>\n        \n        {show ? <TrendingSearches /> : null}\n    </div>\n}"]},"metadata":{},"sourceType":"module"}