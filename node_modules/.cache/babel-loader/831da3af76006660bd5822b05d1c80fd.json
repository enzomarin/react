{"ast":null,"code":"var _jsxFileName = \"/home/emarin/Escritorio/Dev/miduDevBootcamp/react/react-live-coding/src/components/TrendingSearches/index.js\";\nimport React, { useEffect, useState, useRef } from 'react';\nimport getTrendingTerms from '../../services/getTrendingTermsServices';\nimport Category from '../Category';\n\nfunction TrendingSearches() {\n  const [trends, setTrends] = useState([]);\n  useEffect(function () {\n    getTrendingTerms().then(setTrends);\n  }, []);\n  return /*#__PURE__*/React.createElement(Category, {\n    name: \"Tendencias\",\n    options: trends,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 12\n    }\n  });\n}\n\nfunction useNearScreen({\n  elementRef\n}) {\n  const [show, setShow] = useState(false); // cuando cambia su valor, vuelve a renderizar el componente\n\n  useEffect(function () {\n    // Funcion a ejecutar cuando haya cambios en la interseccion\n    const onChange = (entries, observer) => {\n      //Recuperamos el elemento\n      const el = entries[0]; // si el elemento es intersectado\n\n      if (el.isIntersecting) {\n        setShow(true); // desconectamos, de manera que no siga observando\n\n        observer.disconnect();\n      }\n    }; // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n\n\n    const observer = new IntersectionObserver(onChange, {\n      rootMargin: '100px'\n    }); //empezamos a observar\n    // para acceder al valor de la referencia se ocupa .current\n\n    observer.observe(elementRef.current); // recibe el elemento a observar\n    // cuando el componente se deje de utilizar limpie el evento\n\n    return () => observer.disconnect();\n  });\n}\n\nexport default function LazyTrending() {\n  const elementRef = useRef(); // permite guardar valores que se mantienen entre rerendizados\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: elementRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 12\n    }\n  }, show ? /*#__PURE__*/React.createElement(TrendingSearches, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 17\n    }\n  }) : null);\n}","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react/react-live-coding/src/components/TrendingSearches/index.js"],"names":["React","useEffect","useState","useRef","getTrendingTerms","Category","TrendingSearches","trends","setTrends","then","useNearScreen","elementRef","show","setShow","onChange","entries","observer","el","isIntersecting","disconnect","IntersectionObserver","rootMargin","observe","current","LazyTrending"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,QAAmD,OAAnD;AACA,OAAOC,gBAAP,MAA6B,yCAA7B;AACA,OAAOC,QAAP,MAAqB,aAArB;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,EAAD,CAApC;AAIAD,EAAAA,SAAS,CAAC,YAAW;AAEjBG,IAAAA,gBAAgB,GAAGK,IAAnB,CAAwBD,SAAxB;AACH,GAHQ,EAGN,EAHM,CAAT;AAKA,sBAAO,oBAAC,QAAD;AAAU,IAAA,IAAI,EAAE,YAAhB;AAA6B,IAAA,OAAO,EAAID,MAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAP;AACH;;AACD,SAASG,aAAT,CAAuB;AAACC,EAAAA;AAAD,CAAvB,EAAoC;AAChC,QAAM,CAACC,IAAD,EAAMC,OAAN,IAAiBX,QAAQ,CAAC,KAAD,CAA/B,CADgC,CACM;;AAEtCD,EAAAA,SAAS,CAAC,YAAU;AAChB;AACA,UAAMa,QAAQ,GAAG,CAACC,OAAD,EAAUC,QAAV,KAAsB;AACnC;AACA,YAAMC,EAAE,GAAGF,OAAO,CAAC,CAAD,CAAlB,CAFmC,CAGnC;;AACA,UAAIE,EAAE,CAACC,cAAP,EAAsB;AAClBL,QAAAA,OAAO,CAAC,IAAD,CAAP,CADkB,CAElB;;AACAG,QAAAA,QAAQ,CAACG,UAAT;AACH;AACJ,KATD,CAFgB,CAahB;;;AACA,UAAMH,QAAQ,GAAG,IAAII,oBAAJ,CAAyBN,QAAzB,EAAmC;AAChDO,MAAAA,UAAU,EAAC;AADqC,KAAnC,CAAjB,CAdgB,CAkBhB;AACA;;AACAL,IAAAA,QAAQ,CAACM,OAAT,CAAiBX,UAAU,CAACY,OAA5B,EApBgB,CAoBqB;AAErC;;AACA,WAAO,MAAMP,QAAQ,CAACG,UAAT,EAAb;AACH,GAxBQ,CAAT;AAyBH;;AACD,eAAe,SAASK,YAAT,GAAuB;AAElC,QAAMb,UAAU,GAAGR,MAAM,EAAzB,CAFkC,CAEN;;AAI5B,sBAAO;AAAK,IAAA,GAAG,EAAIQ,UAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAEFC,IAAI,gBAAG,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAH,GAA0B,IAF5B,CAAP;AAIH","sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\nimport getTrendingTerms from '../../services/getTrendingTermsServices'\nimport Category from '../Category'\n\nfunction TrendingSearches (){\n    const [trends, setTrends] = useState([])\n    \n\n\n    useEffect(function() {\n\n        getTrendingTerms().then(setTrends)\n    }, [])\n    \n    return <Category name= 'Tendencias' options = {trends}/>\n}\nfunction useNearScreen({elementRef}){\n    const [show,setShow] = useState(false)// cuando cambia su valor, vuelve a renderizar el componente\n\n    useEffect(function(){\n        // Funcion a ejecutar cuando haya cambios en la interseccion\n        const onChange = (entries, observer) =>{\n            //Recuperamos el elemento\n            const el = entries[0]\n            // si el elemento es intersectado\n            if (el.isIntersecting){\n                setShow(true)\n                // desconectamos, de manera que no siga observando\n                observer.disconnect()\n            }\n        }\n\n        // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n        const observer = new IntersectionObserver(onChange, {\n            rootMargin:'100px'\n        })\n\n        //empezamos a observar\n        // para acceder al valor de la referencia se ocupa .current\n        observer.observe(elementRef.current) // recibe el elemento a observar\n        \n        // cuando el componente se deje de utilizar limpie el evento\n        return () => observer.disconnect()\n    })\n}\nexport default function LazyTrending(){\n   \n    const elementRef = useRef() // permite guardar valores que se mantienen entre rerendizados\n    \n\n\n    return <div ref = {elementRef}>\n        \n        {show ? <TrendingSearches /> : null}\n    </div>\n}"]},"metadata":{},"sourceType":"module"}