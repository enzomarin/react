{"ast":null,"code":"import locationHook from \"./use-location.js\";\nimport makeMatcher from \"./matcher.js\";\nimport { useRef, useLayoutEffect, useContext, useCallback, createContext, isValidElement, cloneElement, createElement as h } from \"./react-deps.js\";\n/*\n * Part 1, Hooks API: useRouter, useRoute and useLocation\n */\n// one of the coolest features of `createContext`:\n// when no value is provided — default object is used.\n// allows us to use the router context as a global ref to store\n// the implicitly created router (see `useRouter` below)\n\nconst RouterCtx = createContext({});\n\nconst buildRouter = ({\n  hook = locationHook,\n  base = \"\",\n  matcher = makeMatcher()\n} = {}) => ({\n  hook,\n  base,\n  matcher\n});\n\nexport const useRouter = () => {\n  const globalRef = useContext(RouterCtx); // either obtain the router from the outer context (provided by the\n  // `<Router /> component) or create an implicit one on demand.\n\n  return globalRef.v || (globalRef.v = buildRouter());\n};\nexport const useLocation = () => {\n  const router = useRouter();\n  return router.hook(router);\n};\nexport const useRoute = pattern => {\n  const [path] = useLocation();\n  return useRouter().matcher(pattern, path);\n};\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nexport const Router = props => {\n  const ref = useRef(null); // this little trick allows to avoid having unnecessary\n  // calls to potentially expensive `buildRouter` method.\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n\n  const value = ref.current || (ref.current = {\n    v: buildRouter(props)\n  });\n  return h(RouterCtx.Provider, {\n    value: value,\n    children: props.children\n  });\n};\nexport const Route = ({\n  path,\n  match,\n  component,\n  children\n}) => {\n  const useRouteMatch = useRoute(path); // `props.match` is present - Route is controlled by the Switch\n\n  const [matches, params] = match || useRouteMatch;\n  if (!matches) return null; // React-Router style `component` prop\n\n  if (component) return h(component, {\n    params\n  }); // support render prop or plain children\n\n  return typeof children === \"function\" ? children(params) : children;\n};\nexport const Link = props => {\n  const [, navigate] = useLocation();\n  const {\n    base\n  } = useRouter();\n  const href = props.href || props.to;\n  const {\n    children,\n    onClick\n  } = props;\n  const handleClick = useCallback(event => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;\n    event.preventDefault();\n    navigate(href);\n    onClick && onClick(event);\n  }, [href, onClick, navigate]); // wraps children in `a` if needed\n\n  const extraProps = {\n    href: base + href,\n    onClick: handleClick,\n    to: null\n  };\n  const jsx = isValidElement(children) ? children : h(\"a\", props);\n  return cloneElement(jsx, extraProps);\n};\nexport const Switch = ({\n  children,\n  location\n}) => {\n  const {\n    matcher\n  } = useRouter();\n  const [originalLocation] = useLocation();\n  children = Array.isArray(children) ? children : [children];\n\n  for (const element of children) {\n    let match = 0;\n    if (isValidElement(element) && // we don't require an element to be of type Route,\n    // but we do require it to contain a truthy `path` prop.\n    // this allows to use different components that wrap Route\n    // inside of a switch, for example <AnimatedRoute />.\n    element.props.path && (match = matcher(element.props.path, location || originalLocation))[0]) return cloneElement(element, {\n      match\n    });\n  }\n\n  return null;\n};\nexport const Redirect = props => {\n  const [, push] = useLocation();\n  useLayoutEffect(() => {\n    push(props.href || props.to); // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\nexport default useRoute;","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react/react-live-coding/node_modules/wouter/index.js"],"names":["locationHook","makeMatcher","useRef","useLayoutEffect","useContext","useCallback","createContext","isValidElement","cloneElement","createElement","h","RouterCtx","buildRouter","hook","base","matcher","useRouter","globalRef","v","useLocation","router","useRoute","pattern","path","Router","props","ref","value","current","Provider","children","Route","match","component","useRouteMatch","matches","params","Link","navigate","href","to","onClick","handleClick","event","ctrlKey","metaKey","altKey","shiftKey","button","preventDefault","extraProps","jsx","Switch","location","originalLocation","Array","isArray","element","Redirect","push"],"mappings":"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","sourcesContent":["import locationHook from \"./use-location.js\";\nimport makeMatcher from \"./matcher.js\";\n\nimport {\n  useRef,\n  useLayoutEffect,\n  useContext,\n  useCallback,\n  createContext,\n  isValidElement,\n  cloneElement,\n  createElement as h\n} from \"./react-deps.js\";\n\n/*\n * Part 1, Hooks API: useRouter, useRoute and useLocation\n */\n\n// one of the coolest features of `createContext`:\n// when no value is provided — default object is used.\n// allows us to use the router context as a global ref to store\n// the implicitly created router (see `useRouter` below)\nconst RouterCtx = createContext({});\n\nconst buildRouter = ({\n  hook = locationHook,\n  base = \"\",\n  matcher = makeMatcher()\n} = {}) => ({ hook, base, matcher });\n\nexport const useRouter = () => {\n  const globalRef = useContext(RouterCtx);\n\n  // either obtain the router from the outer context (provided by the\n  // `<Router /> component) or create an implicit one on demand.\n  return globalRef.v || (globalRef.v = buildRouter());\n};\n\nexport const useLocation = () => {\n  const router = useRouter();\n  return router.hook(router);\n};\n\nexport const useRoute = pattern => {\n  const [path] = useLocation();\n  return useRouter().matcher(pattern, path);\n};\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nexport const Router = props => {\n  const ref = useRef(null);\n\n  // this little trick allows to avoid having unnecessary\n  // calls to potentially expensive `buildRouter` method.\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n  const value = ref.current || (ref.current = { v: buildRouter(props) });\n\n  return h(RouterCtx.Provider, {\n    value: value,\n    children: props.children\n  });\n};\n\nexport const Route = ({ path, match, component, children }) => {\n  const useRouteMatch = useRoute(path);\n\n  // `props.match` is present - Route is controlled by the Switch\n  const [matches, params] = match || useRouteMatch;\n\n  if (!matches) return null;\n\n  // React-Router style `component` prop\n  if (component) return h(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\nexport const Link = props => {\n  const [, navigate] = useLocation();\n  const { base } = useRouter();\n\n  const href = props.href || props.to;\n  const { children, onClick } = props;\n\n  const handleClick = useCallback(\n    event => {\n      // ignores the navigation when clicked using right mouse button or\n      // by holding a special modifier key: ctrl, command, win, alt, shift\n      if (\n        event.ctrlKey ||\n        event.metaKey ||\n        event.altKey ||\n        event.shiftKey ||\n        event.button !== 0\n      )\n        return;\n\n      event.preventDefault();\n      navigate(href);\n      onClick && onClick(event);\n    },\n    [href, onClick, navigate]\n  );\n\n  // wraps children in `a` if needed\n  const extraProps = { href: base + href, onClick: handleClick, to: null };\n  const jsx = isValidElement(children) ? children : h(\"a\", props);\n\n  return cloneElement(jsx, extraProps);\n};\n\nexport const Switch = ({ children, location }) => {\n  const { matcher } = useRouter();\n  const [originalLocation] = useLocation();\n\n  children = Array.isArray(children) ? children : [children];\n\n  for (const element of children) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      element.props.path &&\n      (match = matcher(element.props.path, location || originalLocation))[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nexport const Redirect = props => {\n  const [, push] = useLocation();\n  useLayoutEffect(() => {\n    push(props.href || props.to);\n\n    // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\n\nexport default useRoute;\n"]},"metadata":{},"sourceType":"module"}