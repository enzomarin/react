{"ast":null,"code":"var _jsxFileName = \"/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js\";\nimport React, { useEffect, useState, useRef } from 'react';\nimport getTrendingTerms from '../../services/getTrendingTermsServices';\nimport Category from '../Category';\n\nfunction TrendingSearches() {\n  const [trends, setTrends] = useState([]);\n  useEffect(function () {\n    getTrendingTerms().then(setTrends);\n  }, []);\n  return /*#__PURE__*/React.createElement(Category, {\n    name: \"Tendencias\",\n    options: trends,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 12\n    }\n  });\n}\n\nexport default function LazyTrending() {\n  const [show, setShow] = useState(false);\n  const elementRef = useRef();\n  useEffect(function () {\n    // Funcion a ejecutar cuando haya cambios en la interseccion\n    const onChange = (entries, observer) => {\n      //Recuperamos el elemento\n      const el = entries[0];\n      console.log(el.isIntersecting); // si el elemento es intersectado\n\n      if (el.isIntersecting) {\n        setShow(true);\n        observer.disconnect();\n      }\n    }; // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n\n\n    const observer = new IntersectionObserver(onChange, {\n      rootMargin: '100px'\n    }); //empezamos a observar\n    // para acceder al valor de la referencia se ocupa .current\n\n    observer.observe(elementRef.current); // recibe el elemento a observar\n  });\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: elementRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44,\n      columnNumber: 12\n    }\n  }, show ? /*#__PURE__*/React.createElement(TrendingSearches, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 46,\n      columnNumber: 17\n    }\n  }) : null);\n}","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react-live-coding/src/components/TrendingSearches/index.js"],"names":["React","useEffect","useState","useRef","getTrendingTerms","Category","TrendingSearches","trends","setTrends","then","LazyTrending","show","setShow","elementRef","onChange","entries","observer","el","console","log","isIntersecting","disconnect","IntersectionObserver","rootMargin","observe","current"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,QAAmD,OAAnD;AACA,OAAOC,gBAAP,MAA6B,yCAA7B;AACA,OAAOC,QAAP,MAAqB,aAArB;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,EAAD,CAApC;AAIAD,EAAAA,SAAS,CAAC,YAAW;AAEjBG,IAAAA,gBAAgB,GAAGK,IAAnB,CAAwBD,SAAxB;AACH,GAHQ,EAGN,EAHM,CAAT;AAKA,sBAAO,oBAAC,QAAD;AAAU,IAAA,IAAI,EAAE,YAAhB;AAA6B,IAAA,OAAO,EAAID,MAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAP;AACH;;AAED,eAAe,SAASG,YAAT,GAAuB;AAClC,QAAM,CAACC,IAAD,EAAMC,OAAN,IAAiBV,QAAQ,CAAC,KAAD,CAA/B;AACA,QAAMW,UAAU,GAAGV,MAAM,EAAzB;AACAF,EAAAA,SAAS,CAAC,YAAU;AAChB;AACA,UAAMa,QAAQ,GAAG,CAACC,OAAD,EAAUC,QAAV,KAAsB;AACnC;AACA,YAAMC,EAAE,GAAGF,OAAO,CAAC,CAAD,CAAlB;AACAG,MAAAA,OAAO,CAACC,GAAR,CAAYF,EAAE,CAACG,cAAf,EAHmC,CAInC;;AACA,UAAIH,EAAE,CAACG,cAAP,EAAsB;AAClBR,QAAAA,OAAO,CAAC,IAAD,CAAP;AACAI,QAAAA,QAAQ,CAACK,UAAT;AACH;AACJ,KATD,CAFgB,CAahB;;;AACA,UAAML,QAAQ,GAAG,IAAIM,oBAAJ,CAAyBR,QAAzB,EAAmC;AAChDS,MAAAA,UAAU,EAAC;AADqC,KAAnC,CAAjB,CAdgB,CAkBhB;AACA;;AACAP,IAAAA,QAAQ,CAACQ,OAAT,CAAiBX,UAAU,CAACY,OAA5B,EApBgB,CAoBqB;AACxC,GArBQ,CAAT;AAuBA,sBAAO;AAAK,IAAA,GAAG,EAAIZ,UAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAEFF,IAAI,gBAAG,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAH,GAA0B,IAF5B,CAAP;AAIH","sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\nimport getTrendingTerms from '../../services/getTrendingTermsServices'\nimport Category from '../Category'\n\nfunction TrendingSearches (){\n    const [trends, setTrends] = useState([])\n    \n\n\n    useEffect(function() {\n\n        getTrendingTerms().then(setTrends)\n    }, [])\n    \n    return <Category name= 'Tendencias' options = {trends}/>\n}\n\nexport default function LazyTrending(){\n    const [show,setShow] = useState(false)\n    const elementRef = useRef()\n    useEffect(function(){\n        // Funcion a ejecutar cuando haya cambios en la interseccion\n        const onChange = (entries, observer) =>{\n            //Recuperamos el elemento\n            const el = entries[0]\n            console.log(el.isIntersecting)\n            // si el elemento es intersectado\n            if (el.isIntersecting){\n                setShow(true)\n                observer.disconnect()\n            }\n        }\n\n        // recibe 2 parametro   s, el callback a ejecutar, y un objeto de opciones\n        const observer = new IntersectionObserver(onChange, {\n            rootMargin:'100px'\n        })\n\n        //empezamos a observar\n        // para acceder al valor de la referencia se ocupa .current\n        observer.observe(elementRef.current) // recibe el elemento a observar\n    })\n\n    return <div ref = {elementRef}>\n        \n        {show ? <TrendingSearches /> : null}\n    </div>\n}"]},"metadata":{},"sourceType":"module"}