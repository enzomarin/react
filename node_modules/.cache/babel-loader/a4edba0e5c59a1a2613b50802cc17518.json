{"ast":null,"code":"import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\nexport default (({\n  base = \"\"\n} = {}) => {\n  const [path, update] = useState(currentPathname(base));\n  const prevPath = useRef(path);\n  useEffect(() => {\n    patchHistoryEvents(); // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      prevPath.current !== pathname && update(prevPath.current = pathname);\n    };\n\n    const events = [\"popstate\", \"pushState\", \"replaceState\"];\n    events.map(e => addEventListener(e, checkForUpdates)); // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n\n    checkForUpdates();\n    return () => events.map(e => removeEventListener(e, checkForUpdates));\n  }, []); // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n\n  const navigate = useCallback((to, replace) => history[replace ? \"replaceState\" : \"pushState\"](0, 0, base + to), []);\n  return [path, navigate];\n}); // While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\nlet patched = 0;\n\nconst patchHistoryEvents = () => {\n  if (patched) return;\n  [\"pushState\", \"replaceState\"].map(type => {\n    const original = history[type];\n\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n      dispatchEvent(event);\n      return result;\n    };\n  });\n  return patched = 1;\n};\n\nconst currentPathname = (base, path = location.pathname) => !path.indexOf(base) ? path.slice(base.length) || \"/\" : path;","map":{"version":3,"sources":["/home/emarin/Escritorio/Dev/miduDevBootcamp/react/react-live-coding/node_modules/wouter/use-location.js"],"names":["useEffect","useRef","useState","useCallback","base","path","update","currentPathname","prevPath","patchHistoryEvents","checkForUpdates","pathname","current","events","map","e","addEventListener","removeEventListener","navigate","to","replace","history","patched","type","original","result","apply","arguments","event","Event","dispatchEvent","location","indexOf","slice","length"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,EAA4BC,QAA5B,EAAsCC,WAAtC,QAAyD,iBAAzD;AAEA,gBAAe,CAAC;AAAEC,EAAAA,IAAI,GAAG;AAAT,IAAgB,EAAjB,KAAwB;AACrC,QAAM,CAACC,IAAD,EAAOC,MAAP,IAAiBJ,QAAQ,CAACK,eAAe,CAACH,IAAD,CAAhB,CAA/B;AACA,QAAMI,QAAQ,GAAGP,MAAM,CAACI,IAAD,CAAvB;AAEAL,EAAAA,SAAS,CAAC,MAAM;AACdS,IAAAA,kBAAkB,GADJ,CAGd;AACA;AACA;AACA;;AACA,UAAMC,eAAe,GAAG,MAAM;AAC5B,YAAMC,QAAQ,GAAGJ,eAAe,CAACH,IAAD,CAAhC;AACAI,MAAAA,QAAQ,CAACI,OAAT,KAAqBD,QAArB,IAAiCL,MAAM,CAAEE,QAAQ,CAACI,OAAT,GAAmBD,QAArB,CAAvC;AACD,KAHD;;AAKA,UAAME,MAAM,GAAG,CAAC,UAAD,EAAa,WAAb,EAA0B,cAA1B,CAAf;AACAA,IAAAA,MAAM,CAACC,GAAP,CAAWC,CAAC,IAAIC,gBAAgB,CAACD,CAAD,EAAIL,eAAJ,CAAhC,EAbc,CAed;AACA;AACA;;AACAA,IAAAA,eAAe;AAEf,WAAO,MAAMG,MAAM,CAACC,GAAP,CAAWC,CAAC,IAAIE,mBAAmB,CAACF,CAAD,EAAIL,eAAJ,CAAnC,CAAb;AACD,GArBQ,EAqBN,EArBM,CAAT,CAJqC,CA2BrC;AACA;AACA;AACA;AACA;;AACA,QAAMQ,QAAQ,GAAGf,WAAW,CAC1B,CAACgB,EAAD,EAAKC,OAAL,KACEC,OAAO,CAACD,OAAO,GAAG,cAAH,GAAoB,WAA5B,CAAP,CAAgD,CAAhD,EAAmD,CAAnD,EAAsDhB,IAAI,GAAGe,EAA7D,CAFwB,EAG1B,EAH0B,CAA5B;AAMA,SAAO,CAACd,IAAD,EAAOa,QAAP,CAAP;AACD,CAvCD,E,CAyCA;AACA;AACA;AACA;AACA;;AAEA,IAAII,OAAO,GAAG,CAAd;;AAEA,MAAMb,kBAAkB,GAAG,MAAM;AAC/B,MAAIa,OAAJ,EAAa;AAEb,GAAC,WAAD,EAAc,cAAd,EAA8BR,GAA9B,CAAkCS,IAAI,IAAI;AACxC,UAAMC,QAAQ,GAAGH,OAAO,CAACE,IAAD,CAAxB;;AAEAF,IAAAA,OAAO,CAACE,IAAD,CAAP,GAAgB,YAAW;AACzB,YAAME,MAAM,GAAGD,QAAQ,CAACE,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAAf;AACA,YAAMC,KAAK,GAAG,IAAIC,KAAJ,CAAUN,IAAV,CAAd;AACAK,MAAAA,KAAK,CAACD,SAAN,GAAkBA,SAAlB;AAEAG,MAAAA,aAAa,CAACF,KAAD,CAAb;AACA,aAAOH,MAAP;AACD,KAPD;AAQD,GAXD;AAaA,SAAQH,OAAO,GAAG,CAAlB;AACD,CAjBD;;AAmBA,MAAMf,eAAe,GAAG,CAACH,IAAD,EAAOC,IAAI,GAAG0B,QAAQ,CAACpB,QAAvB,KACtB,CAACN,IAAI,CAAC2B,OAAL,CAAa5B,IAAb,CAAD,GAAsBC,IAAI,CAAC4B,KAAL,CAAW7B,IAAI,CAAC8B,MAAhB,KAA2B,GAAjD,GAAuD7B,IADzD","sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\n\nexport default ({ base = \"\" } = {}) => {\n  const [path, update] = useState(currentPathname(base));\n  const prevPath = useRef(path);\n\n  useEffect(() => {\n    patchHistoryEvents();\n\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      prevPath.current !== pathname && update((prevPath.current = pathname));\n    };\n\n    const events = [\"popstate\", \"pushState\", \"replaceState\"];\n    events.map(e => addEventListener(e, checkForUpdates));\n\n    // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n    checkForUpdates();\n\n    return () => events.map(e => removeEventListener(e, checkForUpdates));\n  }, []);\n\n  // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  const navigate = useCallback(\n    (to, replace) =>\n      history[replace ? \"replaceState\" : \"pushState\"](0, 0, base + to),\n    []\n  );\n\n  return [path, navigate];\n};\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\nlet patched = 0;\n\nconst patchHistoryEvents = () => {\n  if (patched) return;\n\n  [\"pushState\", \"replaceState\"].map(type => {\n    const original = history[type];\n\n    history[type] = function() {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n\n      dispatchEvent(event);\n      return result;\n    };\n  });\n\n  return (patched = 1);\n};\n\nconst currentPathname = (base, path = location.pathname) =>\n  !path.indexOf(base) ? path.slice(base.length) || \"/\" : path;\n"]},"metadata":{},"sourceType":"module"}